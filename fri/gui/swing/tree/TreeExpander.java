package fri.gui.swing.tree;

import java.util.*;
import javax.swing.*;
import javax.swing.tree.*;

/**
	Utility methods to expand a JTree and to fetch expanded pathes
	from a JTree. This is primarily for making persistent the tree
	state.<br>
	For expanding and selecting a tree node the passed path parts
	get separated by "|" (e.g. "Root Node|First Child|Second Level").
	The same format will be generated by the fetching methods
	getSelectedPathes() and getOpenPathes().
*/

public abstract class TreeExpander
{
	private static final String SEPARATOR = "|";
	
	
	private TreeExpander()	{}
	
	/**
		Expands all branches of a JTree.<br>
		<b>CAUTION:</b> Do not apply this to recursive trees!
		@return true if at least one expansion has been done
	*/
	public static boolean expandAllBranches(JTree tree) {
		int rows = -1, newRows = 0;
		boolean isDone = false;
		while (rows < newRows) {
			rows = tree.getRowCount();
			for (int i = 0; i < rows; i++) {
				isDone = true;
				tree.expandRow(i);
			}
			newRows = tree.getRowCount();
		}
		return isDone;
	}

	/**
		Expands all branches under passed TreeNode.<br>
		<b>CAUTION:</b> Do not apply this to recursive trees!
	*/
	public static void expandBranches(JTree tree, DefaultMutableTreeNode node) {
		if (node.isLeaf())
			return;

		tree.expandPath(new TreePath(node.getPath()));

		for (int i = 0; i < node.getChildCount(); i++)	{
			DefaultMutableTreeNode n = (DefaultMutableTreeNode)node.getChildAt(i);
			expandBranches(tree, n);
		}
	}



	/**
		Scrolls JTree to the given TreePath using SwingUtilities.invokeLater().
	*/
	public static void scrollTo(final TreePath tp, final JTree tree)	{
		if (tp == null)
			return;
		SwingUtilities.invokeLater(new Runnable()	{
			public void run()	{
						System.err.println("scrolling to "+tp);
						tree.scrollPathToVisible(tp);
			}
		});
	}



	// converting string path to Object array
	private static TreePath explorePath(String path, JTree tree, boolean doSelect)	{
		if (path == null || path.length() <= 0 || tree == null)
			return null;
			
		TreeModel m = tree.getModel();
		Object n = m.getRoot();
		StringTokenizer stok = new StringTokenizer(path, SEPARATOR);
		
		String p = stok.hasMoreTokens() ? stok.nextToken() : "";

		if (p.equals(n.toString()) == false)	{
			if (n.toString().equals(""))	{	// maybe root not shown
				stok = new StringTokenizer(path, SEPARATOR);	// load again as first has been removed
			}
			else	{
				System.err.println("ERROR: Wrong tree root: "+p+", having: "+n.toString());
				return null;	// root is wrong
			}
		}	// else: first element was removed from path

		Vector v = new Vector(stok.countTokens());
		while (stok.hasMoreTokens())
			v.add(stok.nextToken());

		Object [] arr = new Object[v.size()];
		v.copyInto(arr);

		return explorePath(arr, tree, doSelect, null);
	}


	private static TreePath explorePath(Object [] path, JTree tree, boolean doSelect, Comparator comparator)	{
		if (path == null || path.length <= 0 || tree == null)
			return null;

		TreeModel m = tree.getModel();
		Object n = m.getRoot();
		
		Vector v = new Vector(path.length);
		v.add(n);	// add root to tree path

		int j = 0;
		if (equalsNodeToObject(n, path[0], comparator) != null)
			j = 1;	// start at second path element

		for (; j < path.length && n != null; j++)	{	// explore path
			Object o = path[j];
				
			int max = m.getChildCount(n);
			Object found = null;

			for (int i = 0; found == null && i < max; i++)	{	// loop child nodes
				Object n1 = m.getChild(n, i);

				found = equalsNodeToObject(n1, o, comparator);
				if (found != null)
					v.add(n = found);
			}

			if (found == null)	{	// break loop
				//System.err.println("breaking loop at object "+o);
				n = null;
			}
		}
		
		return explorePath(v, tree, doSelect);
	}


	private static Object equalsNodeToObject(Object n1, Object o, Comparator comparator)	{
		if (comparator == null)	// do default string comparison
			return n1.toString().equals(o.toString()) ? n1 : null;
		return comparator.compare(n1, o) == 0 ? n1 : null;
	}
	
	private static TreePath explorePath(Vector v, JTree tree, boolean doSelect)	{
		Object [] oarr = new Object[v.size()];
		v.copyInto(oarr);
		TreePath tp = new TreePath(oarr);

		if (doSelect)	{
			tree.addSelectionPath(tp);
		}
		else	{
			tree.expandPath(tp);
		}
		return tp;
	}




	// returns list of TreePath
	private static TreePath [] getOpenTreePathes(JTree tree, boolean reduce)	{
		Vector v = new Vector();
		for (int i = 0; i < tree.getRowCount(); i++)
			if (tree.isExpanded(i))
				v.addElement(tree.getPathForRow(i));
		
		if (reduce)	{	// remove redundant pathes
			Vector v1 = new Vector(v.size());

			for (int i = 0; i < v.size(); i++)	{
				TreePath tp = (TreePath)v.elementAt(i);
				boolean takeit = true;

				for (int j = 0; j < v.size(); j++)	{
					if (i == j )
						continue;

					TreePath tp1 = (TreePath)v.elementAt(j);
					if (isDescendantOf(tp1, tp))	// there is a more specialized
						takeit = false;
				}
				if (takeit)	{
					v1.addElement(tp);
				}
			}

			v = v1;	// put it to return code
		}

		TreePath [] pathes = new TreePath[v.size()];
		v.copyInto(pathes);

		return pathes;
	}


	// depends on toString() representation of TreePath
	private static boolean isDescendantOf(TreePath tp, TreePath p)	{
		if (tp.getPathCount() < p.getPathCount())
			return false;
		String tps = tp.toString();
		String ps  =  p.toString();
		ps = ps.substring(0, ps.length() - 1);	// cut last character
		if (tps.startsWith(ps))
			return true;
		return false;
	}


	private static String treePathToString(TreePath tp)	{
		Object [] path = tp.getPath();
		return objectsToString(path);
	}
	
	private static String objectsToString(Object [] path)	{
		String s = new String("");
		for (int i = 0; i < path.length; i++)	{
			if (s.length() <= 0)
				s = path[i].toString();
			else
				s = s+SEPARATOR+path[i].toString();
		}
		return s;
	}



	/**
		Returns an array of all open pathes in tree.
		They are encoded using the "|" separator.
	*/
	public static String [] getOpenPathes(JTree tree)	{
		TreePath [] tps = getOpenTreePathes(tree, true);
		String [] sarr = new String [tps.length];

		for (int i = 0; i < tps.length; i++)	{
			sarr[i] = treePathToString(tps[i]);
		}

		return sarr;
	}

	/**
		Returns an array of all selected pathes in tree.
		They are encoded using the "|" separator.
	*/
	public static String [] getSelectedPathes(JTree tree)	{
		TreePath [] tps = tree.getSelectionPaths();
		if (tps == null)
			return new String [0];

		String [] sarr = new String [tps.length];

		for (int i = 0; i < tps.length; i++)	{
			sarr[i] = treePathToString(tps[i]);
		}

		return sarr;
	}


	/**
		Sets the passed pathes as expanded in tree.
	*/
	public static void setOpenPathes(JTree tree, String [] open)	{
		for (int i = 0; open != null && i < open.length; i++)
			explore(open[i], tree);
	}

	/**
		Sets the passed pathes as selection in tree. Clears selection before.
	*/
	public static void setSelectedPathes(JTree tree, String [] selected)	{
		for (int i = 0; selected != null && i < selected.length; i++)
			select(selected[i], tree);
	}

	/**
		Expands a path of the format described above in a JTree
		@return TreePath if done, else null
	*/
	public static TreePath explore(String path, JTree tree)	{
		return explorePath(path, tree, false);
	}

	/**
		Selects a node in a JTree, given by the format described above.
		The path will be expanded if not.
		@return TreePath if done, else null
	*/
	public static TreePath select(String path, JTree tree)	{
		return explorePath(path, tree, true);
	}



	/**
		Returns all open (expanded) TreePath objects from the tree.
	*/
	public static TreePath [] getOpenTreePathes(JTree tree)	{
		return getOpenTreePathes(tree, false);
	}

	/**
		Returns all selected TreePath objects from the tree.
	*/
	public static TreePath [] getSelectedTreePathes(JTree tree)	{
		return tree.getSelectionPaths();
	}


	/**
		Opens (expands) all TreePath list elements in the tree.
		Uses a Comparator for node comparison. If it is null,
		a toString() comparison is used.
	*/
	public static void setOpenTreePathes(JTree tree, TreePath [] pathes, Comparator comparator)	{
		for (int i = 0; pathes != null && i < pathes.length; i++)	{
			TreePath tp = pathes[i];
			explorePath(tp.getPath(), tree, false, comparator);
		}
	}

	/**
		Opens (expands) all TreePath list elements in the tree.
		Uses a Comparator for node comparison. If it is null,
		a toString() comparison is used.
	*/
	public static void setSelectedTreePathes(JTree tree, TreePath [] pathes, Comparator comparator)	{
		for (int i = 0; pathes != null && i < pathes.length; i++)	{
			TreePath tp = pathes[i];
			explorePath(tp.getPath(), tree, true, comparator);
		}
	}

}
